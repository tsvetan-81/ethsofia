// Initialize web3
const web3 = new Web3(window.ethereum);
let contract;

const contractAddress = "YOUR_CONTRACT_ADDRESS";
const contractABI = [
  /* The ABI generated by Remix */
];

// Wait for MetaMask to connect
async function connect() {
  if (window.ethereum) {
    try {
      // Request account access if needed
      await window.ethereum.request({ method: "eth_requestAccounts" });

      // Connect to the contract
      contract = new web3.eth.Contract(contractABI, contractAddress);
    } catch (error) {
      console.error("User denied account access", error);
    }
  } else {
    alert("MetaMask not detected!");
  }
}

// Call the smart contract to create a challenge
async function createChallenge() {
  const accounts = await web3.eth.getAccounts();
  const title = document.getElementById("challengeTitle").value;
  const techStack = document.getElementById("techStack").value;
  const description = document.getElementById("description").value;

  contract.methods
    .createChallenge(title, techStack, description)
    .send({ from: accounts[0] })
    .on("receipt", function (receipt) {
      alert("Challenge created on blockchain!");
    })
    .on("error", function (error) {
      console.error(error);
    });
}


async function rewardSuccess(challengeIndex, tokensForMentor, tokensForTeam, nftCV) {
    const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
    const sponsor = accounts[0];
    
    contract.methods.rewardMentorAndTeam(challengeIndex, tokensForMentor, tokensForTeam, nftCV)
      .send({ from: sponsor })
      .on('receipt', function(receipt) {
        alert('Tokens distributed successfully to the mentor and the team!');
      })
      .on('error', function(error) {
        console.error(error);
        alert('Failed to distribute tokens.');
      });
  }
